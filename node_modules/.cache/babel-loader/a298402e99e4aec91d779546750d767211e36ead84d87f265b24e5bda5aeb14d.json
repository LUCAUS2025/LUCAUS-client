{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { MAX_Y, MIN_Y } from './BottomSheetOption';\nexport default function useBottomSheet() {\n  _s();\n  const sheet = useRef(null);\n  const content = useRef(null);\n  const metrics = useRef({\n    touchStart: {\n      sheetY: 0,\n      touchY: 0\n    },\n    touchMove: {\n      prevTouchY: 0,\n      movingDirection: 'none'\n    },\n    isContentAreaTouched: false\n  });\n  useEffect(() => {\n    // 바텀 시트가 움직일 수 있는지를 판별하는 함수\n    const canUserMoveBottomSheet = () => {\n      const {\n        touchMove,\n        isContentAreaTouched\n      } = metrics.current;\n      if (!isContentAreaTouched) {\n        return true;\n      }\n\n      // 바텀 시트가 최대로 올라와있는 상태가 아닌 모든 상태\n      if (sheet.current.getBoundingClientRect().y !== MIN_Y) {\n        return true;\n      }\n\n      // 더이상 컨텐츠에서 스크롤 내릴 내용이 없을 때 바텀시트를 움직임\n      if (touchMove.movingDirection === 'down') {\n        return content.current.scrollTop <= 0;\n      }\n      return false;\n    };\n    const handleTouchStart = e => {\n      const {\n        touchStart\n      } = metrics.current;\n      touchStart.sheetY = sheet.current.getBoundingClientRect().y;\n      touchStart.touchY = e.touches[0].clientY;\n    };\n\n    // 터치를 한 상태로 움직일 때 (드래그 할 때)\n    const handleTouchMove = e => {\n      e.preventDefault();\n      const {\n        touchStart,\n        touchMove\n      } = metrics.current;\n      const currentTouch = e.touches[0];\n\n      // 1. 드래그 방향을 정해줌\n      if (touchMove.prevTouchY === 0) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n      if (touchMove.prevTouchY === undefined) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n      if (touchMove.prevTouchY < currentTouch.clientY) {\n        touchMove.movingDirection = 'down';\n      }\n      if (touchMove.prevTouchY > currentTouch.clientY) {\n        touchMove.movingDirection = 'up';\n      }\n\n      // 2. 바텀 시트를 움직여줌\n      if (canUserMoveBottomSheet()) {\n        const touchOffset = currentTouch.clientY - touchStart.touchY;\n        let nextSheetY = touchStart.sheetY + touchOffset; //이동 후의 바텀 시트의 최상단 높이 Y\n\n        if (nextSheetY <= MIN_Y) {\n          nextSheetY = MIN_Y;\n        }\n        if (nextSheetY >= MAX_Y) {\n          nextSheetY = MAX_Y;\n        }\n        sheet.current.style.setProperty('transform', `translateY(${nextSheetY - MAX_Y}px)`);\n      } else {\n        // 컨텐츠를 스크롤하는 동안 body가 스크롤 되는 것 막음\n        document.body.style.overflowY = 'hidden';\n      }\n    };\n    const handleTouchEnd = e => {\n      document.body.style.overflowY = 'auto';\n      const {\n        touchMove\n      } = metrics.current;\n\n      // 드래그가 끝난 후, 현재 위치인 바텀 시트의 최상단 모서리 Y\n      const currentSheetY = sheet.current.getBoundingClientRect().y;\n\n      // 바텀 시트가 최상단 위치가 아닐 경우\n      if (currentSheetY !== MIN_Y) {\n        // 아래로 드래그 했을 경우 바텀시트 아래로 내림\n        if (touchMove.movingDirection === 'down') {\n          sheet.current.style.setProperty('transform', 'translateY(0)');\n        }\n\n        // 위로 드래그 했을 경우 바텀시트 최상단 까지 올림\n        if (touchMove.movingDirection === 'up') {\n          sheet.current.style.setProperty('transform', `translateY(${MIN_Y - MAX_Y}px)`);\n        }\n      }\n      // metrics 초기화\n      metrics.current = {\n        touchStart: {\n          sheetY: 0,\n          touchY: 0\n        },\n        touchMove: {\n          prevTouchY: 0,\n          movingDirection: 'none'\n        },\n        isContentAreaTouched: false\n      };\n    };\n    sheet.current.addEventListener('touchstart', handleTouchStart);\n    sheet.current.addEventListener('touchmove', handleTouchMove);\n    sheet.current.addEventListener('touchend', handleTouchEnd);\n  }, []);\n  useEffect(() => {\n    // 컨텐츠 영억을 터치하고 있을 때 isContentAreaTouched에 true값 대입\n    const handleTouchStart = () => {\n      metrics.current.isContentAreaTouched = true;\n    };\n    content.current.addEventListener('touchstart', handleTouchStart);\n  }, []);\n  return {\n    sheet,\n    content\n  };\n}\n_s(useBottomSheet, \"iFNuaA4mdyYJ5HY44pG28W5G4bE=\");","map":{"version":3,"names":["useEffect","useRef","MAX_Y","MIN_Y","useBottomSheet","_s","sheet","content","metrics","touchStart","sheetY","touchY","touchMove","prevTouchY","movingDirection","isContentAreaTouched","canUserMoveBottomSheet","current","getBoundingClientRect","y","scrollTop","handleTouchStart","e","touches","clientY","handleTouchMove","preventDefault","currentTouch","undefined","touchOffset","nextSheetY","style","setProperty","document","body","overflowY","handleTouchEnd","currentSheetY","addEventListener"],"sources":["/Users/jungsunbeen/Desktop/lucaus-client/src/components/BottomSheet/useBottomSheet.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { MAX_Y, MIN_Y } from './BottomSheetOption';\n\ninterface BottomSheetMetrics {\n  touchStart: {\n    sheetY: number;\n    touchY: number;\n  };\n  touchMove: {\n    prevTouchY?: number;\n    movingDirection: 'none' | 'down' | 'up';\n  };\n  isContentAreaTouched: boolean;\n}\n\nexport default function useBottomSheet() {\n  const sheet = useRef<HTMLDivElement>(null);\n\n  const content = useRef<HTMLDivElement>(null);\n\n  const metrics = useRef<BottomSheetMetrics>({\n    touchStart: {\n      sheetY: 0,\n      touchY: 0,\n    },\n    touchMove: {\n      prevTouchY: 0,\n      movingDirection: 'none',\n    },\n    isContentAreaTouched: false,\n  });\n\n  useEffect(() => {\n    // 바텀 시트가 움직일 수 있는지를 판별하는 함수\n    const canUserMoveBottomSheet = () => {\n      const { touchMove, isContentAreaTouched } = metrics.current;\n\n      if (!isContentAreaTouched) {\n        return true;\n      }\n\n      // 바텀 시트가 최대로 올라와있는 상태가 아닌 모든 상태\n      if (sheet.current!.getBoundingClientRect().y !== MIN_Y) {\n        return true;\n      }\n\n      // 더이상 컨텐츠에서 스크롤 내릴 내용이 없을 때 바텀시트를 움직임\n      if (touchMove.movingDirection === 'down') {\n        return content.current!.scrollTop <= 0;\n      }\n      return false;\n    };\n\n    const handleTouchStart = (e: TouchEvent) => {\n      const { touchStart } = metrics.current;\n      touchStart.sheetY = sheet.current!.getBoundingClientRect().y;\n      touchStart.touchY = e.touches[0].clientY;\n    };\n\n    // 터치를 한 상태로 움직일 때 (드래그 할 때)\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault();\n\n      const { touchStart, touchMove } = metrics.current;\n      const currentTouch = e.touches[0];\n\n      // 1. 드래그 방향을 정해줌\n      if (touchMove.prevTouchY === 0) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n\n      if (touchMove.prevTouchY === undefined) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n\n      if (touchMove.prevTouchY < currentTouch.clientY) {\n        touchMove.movingDirection = 'down';\n      }\n\n      if (touchMove.prevTouchY > currentTouch.clientY) {\n        touchMove.movingDirection = 'up';\n      }\n\n      // 2. 바텀 시트를 움직여줌\n      if (canUserMoveBottomSheet()) {\n        const touchOffset = currentTouch.clientY - touchStart.touchY;\n        let nextSheetY = touchStart.sheetY + touchOffset; //이동 후의 바텀 시트의 최상단 높이 Y\n\n        if (nextSheetY <= MIN_Y) {\n          nextSheetY = MIN_Y;\n        }\n\n        if (nextSheetY >= MAX_Y) {\n          nextSheetY = MAX_Y;\n        }\n\n        sheet.current!.style.setProperty('transform', `translateY(${nextSheetY - MAX_Y}px)`);\n      } else {\n        // 컨텐츠를 스크롤하는 동안 body가 스크롤 되는 것 막음\n        document.body.style.overflowY = 'hidden';\n      }\n    };\n\n    const handleTouchEnd = (e: TouchEvent) => {\n      document.body.style.overflowY = 'auto';\n      const { touchMove } = metrics.current;\n\n      // 드래그가 끝난 후, 현재 위치인 바텀 시트의 최상단 모서리 Y\n      const currentSheetY = sheet.current!.getBoundingClientRect().y;\n\n      // 바텀 시트가 최상단 위치가 아닐 경우\n      if (currentSheetY !== MIN_Y) {\n        // 아래로 드래그 했을 경우 바텀시트 아래로 내림\n        if (touchMove.movingDirection === 'down') {\n          sheet.current!.style.setProperty('transform', 'translateY(0)');\n        }\n\n        // 위로 드래그 했을 경우 바텀시트 최상단 까지 올림\n        if (touchMove.movingDirection === 'up') {\n          sheet.current!.style.setProperty('transform', `translateY(${MIN_Y - MAX_Y}px)`);\n        }\n      }\n      // metrics 초기화\n      metrics.current = {\n        touchStart: {\n          sheetY: 0,\n          touchY: 0,\n        },\n        touchMove: {\n          prevTouchY: 0,\n          movingDirection: 'none',\n        },\n        isContentAreaTouched: false,\n      };\n    };\n\n    sheet.current!.addEventListener('touchstart', handleTouchStart);\n    sheet.current!.addEventListener('touchmove', handleTouchMove);\n    sheet.current!.addEventListener('touchend', handleTouchEnd);\n  }, []);\n\n  useEffect(() => {\n    // 컨텐츠 영억을 터치하고 있을 때 isContentAreaTouched에 true값 대입\n    const handleTouchStart = () => {\n      metrics.current!.isContentAreaTouched = true;\n    };\n    content.current!.addEventListener('touchstart', handleTouchStart);\n  }, []);\n\n  return { sheet, content };\n}\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,KAAK,EAAEC,KAAK,QAAQ,qBAAqB;AAclD,eAAe,SAASC,cAAcA,CAAA,EAAG;EAAAC,EAAA;EACvC,MAAMC,KAAK,GAAGL,MAAM,CAAiB,IAAI,CAAC;EAE1C,MAAMM,OAAO,GAAGN,MAAM,CAAiB,IAAI,CAAC;EAE5C,MAAMO,OAAO,GAAGP,MAAM,CAAqB;IACzCQ,UAAU,EAAE;MACVC,MAAM,EAAE,CAAC;MACTC,MAAM,EAAE;IACV,CAAC;IACDC,SAAS,EAAE;MACTC,UAAU,EAAE,CAAC;MACbC,eAAe,EAAE;IACnB,CAAC;IACDC,oBAAoB,EAAE;EACxB,CAAC,CAAC;EAEFf,SAAS,CAAC,MAAM;IACd;IACA,MAAMgB,sBAAsB,GAAGA,CAAA,KAAM;MACnC,MAAM;QAAEJ,SAAS;QAAEG;MAAqB,CAAC,GAAGP,OAAO,CAACS,OAAO;MAE3D,IAAI,CAACF,oBAAoB,EAAE;QACzB,OAAO,IAAI;MACb;;MAEA;MACA,IAAIT,KAAK,CAACW,OAAO,CAAEC,qBAAqB,CAAC,CAAC,CAACC,CAAC,KAAKhB,KAAK,EAAE;QACtD,OAAO,IAAI;MACb;;MAEA;MACA,IAAIS,SAAS,CAACE,eAAe,KAAK,MAAM,EAAE;QACxC,OAAOP,OAAO,CAACU,OAAO,CAAEG,SAAS,IAAI,CAAC;MACxC;MACA,OAAO,KAAK;IACd,CAAC;IAED,MAAMC,gBAAgB,GAAIC,CAAa,IAAK;MAC1C,MAAM;QAAEb;MAAW,CAAC,GAAGD,OAAO,CAACS,OAAO;MACtCR,UAAU,CAACC,MAAM,GAAGJ,KAAK,CAACW,OAAO,CAAEC,qBAAqB,CAAC,CAAC,CAACC,CAAC;MAC5DV,UAAU,CAACE,MAAM,GAAGW,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;IAC1C,CAAC;;IAED;IACA,MAAMC,eAAe,GAAIH,CAAa,IAAK;MACzCA,CAAC,CAACI,cAAc,CAAC,CAAC;MAElB,MAAM;QAAEjB,UAAU;QAAEG;MAAU,CAAC,GAAGJ,OAAO,CAACS,OAAO;MACjD,MAAMU,YAAY,GAAGL,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC;;MAEjC;MACA,IAAIX,SAAS,CAACC,UAAU,KAAK,CAAC,EAAE;QAC9BD,SAAS,CAACC,UAAU,GAAGJ,UAAU,CAACE,MAAM;MAC1C;MAEA,IAAIC,SAAS,CAACC,UAAU,KAAKe,SAAS,EAAE;QACtChB,SAAS,CAACC,UAAU,GAAGJ,UAAU,CAACE,MAAM;MAC1C;MAEA,IAAIC,SAAS,CAACC,UAAU,GAAGc,YAAY,CAACH,OAAO,EAAE;QAC/CZ,SAAS,CAACE,eAAe,GAAG,MAAM;MACpC;MAEA,IAAIF,SAAS,CAACC,UAAU,GAAGc,YAAY,CAACH,OAAO,EAAE;QAC/CZ,SAAS,CAACE,eAAe,GAAG,IAAI;MAClC;;MAEA;MACA,IAAIE,sBAAsB,CAAC,CAAC,EAAE;QAC5B,MAAMa,WAAW,GAAGF,YAAY,CAACH,OAAO,GAAGf,UAAU,CAACE,MAAM;QAC5D,IAAImB,UAAU,GAAGrB,UAAU,CAACC,MAAM,GAAGmB,WAAW,CAAC,CAAC;;QAElD,IAAIC,UAAU,IAAI3B,KAAK,EAAE;UACvB2B,UAAU,GAAG3B,KAAK;QACpB;QAEA,IAAI2B,UAAU,IAAI5B,KAAK,EAAE;UACvB4B,UAAU,GAAG5B,KAAK;QACpB;QAEAI,KAAK,CAACW,OAAO,CAAEc,KAAK,CAACC,WAAW,CAAC,WAAW,EAAE,cAAcF,UAAU,GAAG5B,KAAK,KAAK,CAAC;MACtF,CAAC,MAAM;QACL;QACA+B,QAAQ,CAACC,IAAI,CAACH,KAAK,CAACI,SAAS,GAAG,QAAQ;MAC1C;IACF,CAAC;IAED,MAAMC,cAAc,GAAId,CAAa,IAAK;MACxCW,QAAQ,CAACC,IAAI,CAACH,KAAK,CAACI,SAAS,GAAG,MAAM;MACtC,MAAM;QAAEvB;MAAU,CAAC,GAAGJ,OAAO,CAACS,OAAO;;MAErC;MACA,MAAMoB,aAAa,GAAG/B,KAAK,CAACW,OAAO,CAAEC,qBAAqB,CAAC,CAAC,CAACC,CAAC;;MAE9D;MACA,IAAIkB,aAAa,KAAKlC,KAAK,EAAE;QAC3B;QACA,IAAIS,SAAS,CAACE,eAAe,KAAK,MAAM,EAAE;UACxCR,KAAK,CAACW,OAAO,CAAEc,KAAK,CAACC,WAAW,CAAC,WAAW,EAAE,eAAe,CAAC;QAChE;;QAEA;QACA,IAAIpB,SAAS,CAACE,eAAe,KAAK,IAAI,EAAE;UACtCR,KAAK,CAACW,OAAO,CAAEc,KAAK,CAACC,WAAW,CAAC,WAAW,EAAE,cAAc7B,KAAK,GAAGD,KAAK,KAAK,CAAC;QACjF;MACF;MACA;MACAM,OAAO,CAACS,OAAO,GAAG;QAChBR,UAAU,EAAE;UACVC,MAAM,EAAE,CAAC;UACTC,MAAM,EAAE;QACV,CAAC;QACDC,SAAS,EAAE;UACTC,UAAU,EAAE,CAAC;UACbC,eAAe,EAAE;QACnB,CAAC;QACDC,oBAAoB,EAAE;MACxB,CAAC;IACH,CAAC;IAEDT,KAAK,CAACW,OAAO,CAAEqB,gBAAgB,CAAC,YAAY,EAAEjB,gBAAgB,CAAC;IAC/Df,KAAK,CAACW,OAAO,CAAEqB,gBAAgB,CAAC,WAAW,EAAEb,eAAe,CAAC;IAC7DnB,KAAK,CAACW,OAAO,CAAEqB,gBAAgB,CAAC,UAAU,EAAEF,cAAc,CAAC;EAC7D,CAAC,EAAE,EAAE,CAAC;EAENpC,SAAS,CAAC,MAAM;IACd;IACA,MAAMqB,gBAAgB,GAAGA,CAAA,KAAM;MAC7Bb,OAAO,CAACS,OAAO,CAAEF,oBAAoB,GAAG,IAAI;IAC9C,CAAC;IACDR,OAAO,CAACU,OAAO,CAAEqB,gBAAgB,CAAC,YAAY,EAAEjB,gBAAgB,CAAC;EACnE,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IAAEf,KAAK;IAAEC;EAAQ,CAAC;AAC3B;AAACF,EAAA,CAvIuBD,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}