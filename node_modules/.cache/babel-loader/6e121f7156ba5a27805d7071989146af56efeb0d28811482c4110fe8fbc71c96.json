{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nimport { MAX_Y, MIN_Y } from './BottomSheetOption';\nexport default function useBottomSheet() {\n  _s();\n  const sheet = useRef(null);\n  const content = useRef(null);\n  const [isSheetOpen, setIsSheetOpen] = useState(false);\n  const metrics = useRef({\n    touchStart: {\n      sheetY: 0,\n      touchY: 0\n    },\n    touchMove: {\n      prevTouchY: 0,\n      movingDirection: 'none'\n    },\n    isContentAreaTouched: false\n  });\n  useEffect(() => {\n    // 바텀 시트가 움직일 수 있는지를 판별하는 함수\n    const canUserMoveBottomSheet = () => {\n      const {\n        touchMove,\n        isContentAreaTouched\n      } = metrics.current;\n      if (!isContentAreaTouched) {\n        return true;\n      }\n\n      // 바텀 시트가 최대로 올라와있는 상태가 아닌 모든 상태\n      if (sheet.current.getBoundingClientRect().y !== MIN_Y) {\n        return true;\n      }\n\n      // 스크롤이 맨 위일 때 아래로 드래그하면 바텀시트를 움직임\n      if (touchMove.movingDirection === 'down') {\n        return content.current.scrollTop <= 0;\n      }\n      return false;\n    };\n    const handleTouchStart = e => {\n      const {\n        touchStart\n      } = metrics.current;\n      touchStart.sheetY = sheet.current.getBoundingClientRect().y;\n      touchStart.touchY = e.touches[0].clientY;\n    };\n\n    // 터치를 한 상태로 움직일 때 (드래그 할 때)\n    const handleTouchMove = e => {\n      //e.preventDefault();\n\n      const {\n        touchStart,\n        touchMove\n      } = metrics.current;\n      const currentTouch = e.touches[0];\n\n      // 1. 드래그 방향을 정해줌\n      if (touchMove.prevTouchY === undefined) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n      if (touchMove.prevTouchY === 0) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n      if (touchMove.prevTouchY < currentTouch.clientY) {\n        touchMove.movingDirection = 'down';\n      }\n      if (touchMove.prevTouchY > currentTouch.clientY) {\n        touchMove.movingDirection = 'up';\n      }\n\n      // 2. 바텀 시트를 움직여줌\n      if (canUserMoveBottomSheet()) {\n        //e.preventDefault();\n\n        const touchOffset = currentTouch.clientY - touchStart.touchY;\n        let nextSheetY = touchStart.sheetY + touchOffset; //이동 후의 바텀 시트의 최상단 높이 Y\n\n        if (nextSheetY <= MIN_Y) {\n          nextSheetY = MIN_Y;\n        }\n        if (nextSheetY >= MAX_Y) {\n          nextSheetY = MAX_Y;\n        }\n        sheet.current.style.setProperty('transform', `translateY(${nextSheetY - MAX_Y}px)`);\n      } else {\n        // 컨텐츠를 스크롤하는 동안 body가 스크롤 되는 것 막음\n        document.body.style.overflowY = 'hidden';\n      }\n    };\n    const handleTouchEnd = e => {\n      const {\n        touchMove\n      } = metrics.current;\n\n      // 드래그가 끝난 후, 현재 위치인 바텀 시트의 최상단 모서리 Y\n      const currentSheetY = sheet.current.getBoundingClientRect().y;\n\n      // 바텀 시트가 최상단 위치가 아닐 경우\n      if (currentSheetY !== MIN_Y) {\n        // 아래로 드래그 했을 경우 바텀시트 아래로 내림\n        if (touchMove.movingDirection === 'down') {\n          sheet.current.style.setProperty('transform', 'translateY(0)');\n          setIsSheetOpen(false);\n        }\n\n        // 위로 드래그 했을 경우 바텀시트 최상단 까지 올림\n        if (touchMove.movingDirection === 'up') {\n          sheet.current.style.setProperty('transform', `translateY(${MIN_Y - MAX_Y}px)`);\n          setIsSheetOpen(true);\n        }\n      }\n      // metrics 초기화\n      metrics.current = {\n        touchStart: {\n          sheetY: 0,\n          touchY: 0\n        },\n        touchMove: {\n          prevTouchY: 0,\n          movingDirection: 'none'\n        },\n        isContentAreaTouched: false\n      };\n    };\n    sheet.current.addEventListener('touchstart', handleTouchStart);\n    sheet.current.addEventListener('touchmove', handleTouchMove);\n    sheet.current.addEventListener('touchend', handleTouchEnd);\n  }, []);\n  useEffect(() => {\n    // 컨텐츠 영억을 터치하고 있을 때 isContentAreaTouched에 true값 대입\n    const handleTouchStart = () => {\n      metrics.current.isContentAreaTouched = true;\n    };\n    content.current.addEventListener('touchstart', handleTouchStart);\n    content.current.style.overflowY = 'hidden';\n  }, []);\n  useEffect(() => {\n    content.current.style.overflowY = isSheetOpen ? 'auto' : 'hidden';\n  }, [isSheetOpen]);\n  return {\n    sheet,\n    content\n  };\n}\n_s(useBottomSheet, \"aHUPdDwvjo/TpLaSwQcF/h7V7iM=\");","map":{"version":3,"names":["useEffect","useRef","useState","MAX_Y","MIN_Y","useBottomSheet","_s","sheet","content","isSheetOpen","setIsSheetOpen","metrics","touchStart","sheetY","touchY","touchMove","prevTouchY","movingDirection","isContentAreaTouched","canUserMoveBottomSheet","current","getBoundingClientRect","y","scrollTop","handleTouchStart","e","touches","clientY","handleTouchMove","currentTouch","undefined","touchOffset","nextSheetY","style","setProperty","document","body","overflowY","handleTouchEnd","currentSheetY","addEventListener"],"sources":["/Users/jungsunbeen/Desktop/lucaus-client/src/components/BottomSheet/useBottomSheet.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { MAX_Y, MIN_Y } from './BottomSheetOption';\n\ninterface BottomSheetMetrics {\n  touchStart: {\n    sheetY: number;\n    touchY: number;\n  };\n  touchMove: {\n    prevTouchY?: number;\n    movingDirection: 'none' | 'down' | 'up';\n  };\n  isContentAreaTouched: boolean;\n}\n\nexport default function useBottomSheet() {\n  const sheet = useRef<HTMLDivElement>(null);\n\n  const content = useRef<HTMLDivElement>(null);\n\n  const [isSheetOpen, setIsSheetOpen] = useState<boolean>(false);\n\n  const metrics = useRef<BottomSheetMetrics>({\n    touchStart: {\n      sheetY: 0,\n      touchY: 0,\n    },\n    touchMove: {\n      prevTouchY: 0,\n      movingDirection: 'none',\n    },\n    isContentAreaTouched: false,\n  });\n\n  useEffect(() => {\n    // 바텀 시트가 움직일 수 있는지를 판별하는 함수\n    const canUserMoveBottomSheet = () => {\n      const { touchMove, isContentAreaTouched } = metrics.current;\n\n      if (!isContentAreaTouched) {\n        return true;\n      }\n\n      // 바텀 시트가 최대로 올라와있는 상태가 아닌 모든 상태\n      if (sheet.current!.getBoundingClientRect().y !== MIN_Y) {\n        return true;\n      }\n\n      // 스크롤이 맨 위일 때 아래로 드래그하면 바텀시트를 움직임\n      if (touchMove.movingDirection === 'down') {\n        return content.current!.scrollTop <= 0;\n      }\n      return false;\n    };\n\n    const handleTouchStart = (e: TouchEvent) => {\n      const { touchStart } = metrics.current;\n      touchStart.sheetY = sheet.current!.getBoundingClientRect().y;\n      touchStart.touchY = e.touches[0].clientY;\n    };\n\n    // 터치를 한 상태로 움직일 때 (드래그 할 때)\n    const handleTouchMove = (e: TouchEvent) => {\n      //e.preventDefault();\n\n      const { touchStart, touchMove } = metrics.current;\n      const currentTouch = e.touches[0];\n\n      // 1. 드래그 방향을 정해줌\n      if (touchMove.prevTouchY === undefined) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n\n      if (touchMove.prevTouchY === 0) {\n        touchMove.prevTouchY = touchStart.touchY;\n      }\n\n      if (touchMove.prevTouchY < currentTouch.clientY) {\n        touchMove.movingDirection = 'down';\n      }\n\n      if (touchMove.prevTouchY > currentTouch.clientY) {\n        touchMove.movingDirection = 'up';\n      }\n\n      // 2. 바텀 시트를 움직여줌\n      if (canUserMoveBottomSheet()) {\n        //e.preventDefault();\n\n        const touchOffset = currentTouch.clientY - touchStart.touchY;\n        let nextSheetY = touchStart.sheetY + touchOffset; //이동 후의 바텀 시트의 최상단 높이 Y\n\n        if (nextSheetY <= MIN_Y) {\n          nextSheetY = MIN_Y;\n        }\n\n        if (nextSheetY >= MAX_Y) {\n          nextSheetY = MAX_Y;\n        }\n\n        sheet.current!.style.setProperty('transform', `translateY(${nextSheetY - MAX_Y}px)`);\n      } else {\n        // 컨텐츠를 스크롤하는 동안 body가 스크롤 되는 것 막음\n        document.body.style.overflowY = 'hidden';\n      }\n    };\n\n    const handleTouchEnd = (e: TouchEvent) => {\n      const { touchMove } = metrics.current;\n\n      // 드래그가 끝난 후, 현재 위치인 바텀 시트의 최상단 모서리 Y\n      const currentSheetY = sheet.current!.getBoundingClientRect().y;\n\n      // 바텀 시트가 최상단 위치가 아닐 경우\n      if (currentSheetY !== MIN_Y) {\n        // 아래로 드래그 했을 경우 바텀시트 아래로 내림\n        if (touchMove.movingDirection === 'down') {\n          sheet.current!.style.setProperty('transform', 'translateY(0)');\n          setIsSheetOpen(false);\n        }\n\n        // 위로 드래그 했을 경우 바텀시트 최상단 까지 올림\n        if (touchMove.movingDirection === 'up') {\n          sheet.current!.style.setProperty('transform', `translateY(${MIN_Y - MAX_Y}px)`);\n          setIsSheetOpen(true);\n        }\n      }\n      // metrics 초기화\n      metrics.current = {\n        touchStart: {\n          sheetY: 0,\n          touchY: 0,\n        },\n        touchMove: {\n          prevTouchY: 0,\n          movingDirection: 'none',\n        },\n        isContentAreaTouched: false,\n      };\n    };\n\n    sheet.current!.addEventListener('touchstart', handleTouchStart);\n    sheet.current!.addEventListener('touchmove', handleTouchMove);\n    sheet.current!.addEventListener('touchend', handleTouchEnd);\n  }, []);\n\n  useEffect(() => {\n    // 컨텐츠 영억을 터치하고 있을 때 isContentAreaTouched에 true값 대입\n    const handleTouchStart = () => {\n      metrics.current!.isContentAreaTouched = true;\n    };\n    content.current!.addEventListener('touchstart', handleTouchStart);\n    content.current!.style.overflowY = 'hidden';\n  }, []);\n\n  useEffect(() => {\n    content.current!.style.overflowY = isSheetOpen ? 'auto' : 'hidden';\n  }, [isSheetOpen]);\n\n  return { sheet, content };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}